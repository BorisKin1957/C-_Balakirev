/*Необходимо объявить четыре критериальных функции для отбора целочисленных
     значений при суммировании в функции sum_ar.Все
         критериальные функции должны иметь сигнатуру :

    int<имя функции>(int);
и быть следующими :

    is_odd : возвращает 1 для нечетных значений и 0 для четных;
is_positive : возвращает 1 для неотрицательных значений и 0 для отрицательных;
is_negative : возвращает 1 для отрицательных значений и 0 для неотрицательных;
deflt
    : возвращает 1 для любых значений.В
          функции sum_ar реализовать подсчет целых чисел переданного массива ar,
    для которых критериальная функция(переданная через указатель) возвращает
    истину(не нулевое значение)
        .Функция sum_ar должна возвращать вычисленную сумму
        .

    В функции main объявить массив указателей с именем funcs на объявленные
    критериальные функции(в порядке их перечисления в задании)
        .Затем,
    сформировать массив marks из прочитанных целочисленных значений в
        количестве не более
        20(необходима проверка на максимальное количество записываемых данных)
            .После этого в операторе switch выполнить подсчет суммы с указанием
        соответствующей критериальной функции из массива funcs.

        Тесты : https
    : // github.com/selfedu-rus/c-tests/tree/main/6.5.5

      Sample Input :

      1 5 4 3 5 6 78 89 56 43 456 45 645 45 44 3 1 4 Sample Output :

      884 */
#include <stdio.h>

// Функции-критерии
int is_odd(int x);          // Проверка на нечётность
int is_positive(int x);     // Проверка на положительность
int is_negative(int x);     // Проверка на отрицательность
int deflt(int x);           // Всегда возвращает истину

// Функция подсчёта суммы с критерием
int sum_ar(const int *ar, size_t len_ar, int (*func)(int));

int main(void) {
    int marks[20] = {0}; // Массив для хранения введённых чисел
    // Массив указателей на критериальные функции
    int (*funcs[4])(int) = {is_odd, is_positive, is_negative, deflt};

    int item = 0;
    scanf("%d", &item); // Выбор критерия суммирования

    int x;
    int *p = marks; // Указатель на начало массива

    // Чтение чисел из ввода
    for (size_t i = 0; i < 20 && scanf("%d", &x) == 1; i++) {
        *p++ = x;
    }

    int sum = 0; // Переменная для хранения результата

    // Вычисление суммы с выбранным критерием
    switch (item) {
        case 1:
            sum = sum_ar(marks, 20, funcs[0]); // Использование is_odd
            break;
        case 2:
            sum = sum_ar(marks, 20, funcs[1]); // Использование is_positive
            break;
        case 3:
            sum = sum_ar(marks, 20, funcs[2]); // Использование is_negative
            break;
        default:
            sum = sum_ar(marks, 20, funcs[3]); // Использование deflt
            break;
    }

    printf("%d\n", sum); // Вывод результата
    return 0;
}

// Функция подсчёта суммы с критерием
int sum_ar(const int *ar, size_t len_ar, int (*func)(int)) {
    int sum = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (func(ar[i])) { // Проверка условия через переданную функцию
            sum += ar[i];  // Добавление элемента, удовлетворяющего условию
        }
    }
    return sum;
}

// Критериальные функции
int is_odd(int x) {
    return x % 2 != 0; // 1 для нечётных, 0 для чётных
}

int is_positive(int x) {
    return x >= 0; // 1 для неотрицательных, 0 для отрицательных
}

int is_negative(int x) {
    return x < 0; // 1 для отрицательных, 0 для неотрицательных
}

int deflt(int x) {
    return 1; // Всегда возвращает истину
}