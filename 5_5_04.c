/* Необходимо после каждого элемента со значением 5 массива digs вставлять новые
элементы со значениями: -1 - после первой найденной пятерки; -2 - после второй
пятерки и т.д. Обратите внимание, что при вставке новых значений, последние
элементы массива digs могут теряться. Также следует учитывать, что элемент со
значением 5 может отсутствовать в массиве digs (тогда ничего вставлять не
нужно). Выведите в консоль по порядку значения всех прочитанных + добавленных
элементов массива digs в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.4

Sample Input:

1 2 5 3 5 4 5 6
Sample Output:

1 2 5 -1 3 5 -2 4 5 -3
 */

#include <stdio.h>

#define TOTAL 10 // количество элементов массива
#define OLD 5 // значение элемента, после которого нужно вставить новый элемент

int main(void) {
    int digs[TOTAL] = {0}, new = -1;
    size_t count = 0, ind_ins, i = 0;
    size_t sz_ar = sizeof(digs) / sizeof(*digs);

    while (count < sz_ar && scanf("%d", &digs[count]) == 1)
        count++;

    for (i; i < count; i++)
        // Ищем в массиве элемент OLD
        if (digs[i] == OLD) {
            ind_ins = i + 1;
            // Сдвигаем элементы справа от OLD на 1 вправо
            for (size_t j = TOTAL - 1; j > ind_ins; j--)
                digs[j] = digs[j - 1];
            // Вставляем новый элемент NEW в позицию (OLD + 1)
            digs[ind_ins] = new;
            // Уменьшаем значение нового элемента
            new --;
            i++;
            // Увеличиваем длину масива при нужде
            if (count < TOTAL)
                count++;
        }

    for (size_t i = 0; i < count; i++)
        printf("%d ", digs[i]);

    return 0;
}