/* Напишите программу, которая читает строку из входного потока (строку целиком
до символа переноса строки). Необходимо ее закодировать азбукой Морзе, где
каждой букве ставится в соответствие код (в виде фрагмента строки) из точки и
тире. После каждой закодированной буквы должен идти пробел (символ окончания
кода буквы). После последнего кода пробела быть не должно (в конце строки).

Коды азбуки Морзе приведены ниже для латинского алфавита (большие и малые буквы
кодируются одинаково), цифр и символа пробела:

A	.-	J	.---	S	...	2	..---
B	-...	K	-.-	T	-	3	...--
C	-.-.	L	.-..	U	..-	4	....-
D	-..	M	--	V	...-	5	.....
E	.	N	-.	W	.--	6	-....
F	..-.	O	---	X	-..-	7	--...
G	--.	P	.--.	Y	-.--	8	---..
H	....	Q	--.-	Z	--..	9	----.
I	..	R	.-.	1	.----	0	-----
Пробел   -...-

Результат кодирования вывести в консоль виде строки.

P. S. Само кодирование лучше реализовать в виде отдельной функции, которой
передается формируемая строка, исходная строка и массив азбуки Морзе.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.7.6

Sample Input:

Sergey Balakirev
Sample Output:

... . .-. --. . -.-- -...- -... .- .-.. .- -.- .. .-. . ...-
 */

#include <stdio.h>
#include <string.h>
char *get_morze_symbol(char);
int main(void) {
    char str[100] = {0};

    fgets(str, sizeof(str) - 1, stdin);
    char *ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте функцию main
    char string[500] = {'\0'}; // строка для вывода длиной 100 * 5 = 500

    for (size_t i = 0; i < strlen(str); i++) { // перебираем строку
        strcat(string,
               get_morze_symbol(str[i])); // добавляем в строку код символа
        if (i != strlen(str) - 1) // если не последний символ
            strcat(string, " "); // добавляем пробел
    }

    puts(string); // выводим строку

    return 0;
}

char *get_morze_symbol(char symbol) {
    char symbols[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 "; // массив символов
    char *morse[] = {
        // массив кодов
        // Буквы A-Z (26 элементов)
        ".-",   // A
        "-...", // B
        "-.-.", // C
        "-..",  // D
        ".",    // E
        "..-.", // F
        "--.",  // G
        "....", // H
        "..",   // I
        ".---", // J
        "-.-",  // K
        ".-..", // L
        "--",   // M
        "-.",   // N
        "---",  // O
        ".--.", // P
        "--.-", // Q
        ".-.",  // R
        "...",  // S
        "-",    // T
        "..-",  // U
        "...-", // V
        ".--",  // W
        "-..-", // X
        "-.--", // Y
        "--..", // Z

        // Цифры 0-9 (10 элементов)
        "-----", // 0
        ".----", // 1
        "..---", // 2
        "...--", // 3
        "....-", // 4
        ".....", // 5
        "-....", // 6
        "--...", // 7
        "---..", // 8
        "----.", // 9

        "-...-" // пробел
    };

    for (size_t i = 0; i < strlen(symbols);
         i++) { // перебираем массив символов symbols
        if (symbol == symbols[i] ||
            symbol == (symbols[i] + 32)) // если символ есть в массиве morze
            return morse[i]; // возвращаем код этого символа
    }
}