/* В массиве строк str хранится информация о count товарах, каждый представлен в
формате:

<наименование товара>: <идентификатор>; <цена>; <вес>

Здесь идентификатор - целое число; цена - целое число; вес - вещественное число.

Необходимо массив указателей p_sort сформировать так, чтобы они ссылались на
отсортированные строки по убыванию веса товара. (Сортировку лучше выполнять
непосредственно массива p_sort.) Выведите в консоль в одну строчку через пробел
наименования товаров, отсортированные по убыванию веса товара.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.8

Sample Input:

часы: 10; 5430; 0.3
компьютер: 13; 132045; 1.23
монитор: 1; 12300; 0.74
колонки: 2; 3245; 0.27
стол: 105; 3400; 5.7
Sample Output:

стол компьютер монитор часы колонки
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 10

int main(void) {
    char str[TOTAL][50], *p_sort[TOTAL] = {'\0'};
    int count = 0;
    while (count < TOTAL && fgets(str[count], sizeof(str) - 1, stdin)) {
        char *ptr_n = strrchr(str[count], '\n');
        if (ptr_n != NULL)
            *ptr_n = '\0';
        count++;
    }
    // здесь продолжайте программу

    float max_weight; // максимальный вес товара
    char archive[TOTAL] = {0}, // массив для хранения информации о том, что
                               // товар уже был обработан
        result[50] = {0}; // строка для хранения результата
    double tmp = 0; // временная переменная для хранения веса товара
    size_t k = 0; // индекс товара с максимальным весом

    // формируем p_sort так, чтобы ссылки ссылались на отсортированные строки по
    // убыванию веса товара
    for (size_t j = 0; j < count; j++) {// цикл по строкам
        max_weight = 0; // обнуляем максимальный вес
        // цикл по строкам, чтобы найти максимальный вес
        for (size_t i = 0; i < count; i++) { 
            if (!archive[i]) { // если товар еще не обработан
                char *ptr = str[i]; // получаем указатель на строку
                tmp = atof(strrchr(ptr, ';') + 1); // получаем вес товара
                if (max_weight < tmp) { // если вес больше максимального
                    max_weight = tmp; // обновляем максимальный вес
                    k = i;  // обновляем индекс товара с максимальным весом
                }
            }
        }
        *(p_sort + j) = str[k]; // сохраняем ссылку на строку в массиве p_sort
        archive[k] = 1; // помечаем товар как обработанный
    }
    // выводим наименования товаров из отсортированного массива p_sort
    for (size_t i = 0; i < count; i++) {
        sscanf(*(p_sort + i), "%s", result); // получаем наименование товара
        char *ptr = strrchr(result, ':'); // получаем указатель на символ ':'
        if (ptr != NULL) // если символ ':' найден
            *ptr = '\0'; // заменяем его на '\0'
        if (i < count - 1) // если это не последний элемент
            printf("%s ", result); // выводим наименование товара C 
        else
            printf("%s", result); // выводим наименование последнего товара
    }

    return 0;
}